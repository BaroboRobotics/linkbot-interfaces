// This file defines control messages transmitted between Linkbot clients (e.g., language bindings)
// and the Linkbot daemon, linkbotd.

syntax = "proto2";

import "nanopb.proto";
import "commontypes.proto";
import "robot.proto";

package linkbot.daemon;

// =============================================================================
// Daemon RPC messages

enum Status {
    // TODO: clean out the deprecated junk from this list

    OK = 0;
    CANNOT_OPEN_DONGLE = 1;
    DONGLE_NOT_FOUND = 2;
    PORT_OUT_OF_RANGE = 3;

    UNREGISTERED_SERIALID = 5;
    INVALID_SERIALID = 6;

    DAEMON_UNAVAILABLE = 7;

    STRANGE_DONGLE = 8;
    INCOMPATIBLE_FIRMWARE = 9;

    BUFFER_OVERFLOW = 10;
    OTHER_ERROR = 11;
}

message getDaemonVersionString {
    message In {}
    message Out {
        optional string value = 1 [(nanopb).max_size = 128];
    }
}

message getDongleCount {
    // Get the number of dongles currently used by the daemon. Normally 0, 1, or 2.

    message In {}
    message Out {
        optional uint32 dongleCount = 1;
    }
}

message addRobotRefs {
    // Add references to a robot in the daemon's robot list. If the ref count for a robot is now 1,
    // the daemon makes a connection to the robot.
    message In {
        repeated SerialId serialIds = 1 [(nanopb).max_count = 16];
    }
    message Out {
        optional Status status = 1;
    }
}

message releaseRobotRefs {
    // Release references to a robot in the daemon's robot list. If the ref count for a robot is now
    // 0, the daemon disconnects from the robot.
    message In {
        repeated SerialId serialIds = 1 [(nanopb).max_count = 16];
    }
    message Out {
        optional Status status = 1;
    }
}

// TODO: Add reordering requests, e.g., slide(robots[x..y] to z) in the ordered list of robots.

message transmit {
    message In {
        optional SerialId destination = 1;
        optional robot.ClientToRobot payload = 2;
    }
    message Out {
        optional Status status = 1;
    }
}

enum BroadcastMethod {
    BROADCAST = 0;
    // A true radio broadcast to all stations within earshot.

    MULTICAST_LOCAL = 1;
    // A multicast radio broadcast to all stations currently connected to the initiating client.

    MULTICAST_GLOBAL = 2;
    // A multicast radio broadcast to all stations currently connected to the daemon.
}

message transmitBroadcast {
    message In {
        optional BroadcastMethod broadcastMethod = 1;
        // If present, determines the behavior of an empty destinations list. If not present, assume
        // defaults to BroadcastMethod.BROADCAST.

        repeated SerialId destinations = 2 [(nanopb).max_count = 8];
        // If `destinations` contains serial IDs, the message is multicast transmitted to
        // the listed serial IDs and `broadcastMethod` is ignored.
        // If `destinations` is empty, the true destinations are determined by `broadcastMethod`.
        //
        // For example:
        //   - ["ZRG6"] multicasts to one station (`broadcastMethod` is ignored)
        //   - ["ZRG6", "2KDV"] multicasts to two stations (`broadcastMethod` is ignored)
        //   - [] depends on the value/presence of `broadcastMethod`:
        //       - all stations by default
        //         (`!has_broadcastMethod || broadcastMethod == BroadcastMethod.BROADCAST`)
        //       - all stations connected to the client
        //         (`broadcastMethod == BroadcastMethod.MULTICAST_LOCAL`)
        //       - all stations connected to the daemon
        //         (`broadcastMethod == BroadcastMethod.MULTICAST_GLOBAL`)

        optional robot.ClientToRobotBroadcast payload = 4;
    }
    message Out {
        optional Status status = 1;
    }
}

// TODO: GetDongleSerialId method

// =============================================================================
// Daemon interface

message RpcRequest {
    optional uint32 requestId = 1;

    oneof arg {
        getDaemonVersionString.In getDaemonVersionString = 2;
        getDongleCount.In getDongleCount = 3;
        addRobotRefs.In addRobotRefs = 4;
        releaseRobotRefs.In releaseRobotRefs = 5;
        transmit.In transmit = 6;
    }
}

message RpcReply {
    optional uint32 requestId = 1;

    oneof arg {
        getDaemonVersionString.Out getDaemonVersionString = 2;
        getDongleCount.Out getDongleCount = 3;
        addRobotRefs.Out addRobotRefs = 4;
        releaseRobotRefs.Out releaseRobotRefs = 5;
        transmit.Out transmit = 6;
    }
}

message ReceiveTransmission {
    optional SerialId serialId = 1;
    optional robot.RobotToClient payload = 2;
}

message DongleEvent {
    optional string firmwareVersion = 1 [(nanopb).max_size = 128];
}

message RobotEvent {
    optional SerialId serialId = 1;
    optional string firmwareVersion = 2 [(nanopb).max_size = 128];
}

// =============================================================================
// Top-level daemon interface messages

message ClientToDaemon {
    // Message sent via WebSocket from a language binding to linkbotd.

    oneof arg {
        RpcRequest rpcRequest = 1;
    }
}

message DaemonToClient {
    // Message sent via WebSocket from linkbotd to a language binding.

    oneof arg {
        RpcReply rpcReply = 1;

        ReceiveTransmission receive = 2;
        DongleEvent dongleEvent = 3;
        RobotEvent robotEvent = 4;
    }
}
